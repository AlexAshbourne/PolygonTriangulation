//////////////////////////////////////////////////////////////////////
//
// BinarySearchTree.h: Need this tree for "event handling" during the
// make monotone function of the triangluation.
//
// I think I am going to use an AVL tree. Balanced and has O(log n) 
// search, insert and delete.
//
// Elements of the tree are edge nodes
//
// Company: Forming Technologies Inc.
//
// REVISIONS:
// Feb. 15, 2017 created (Alex Ashbourne)
//
//////////////////////////////////////////////////////////////////////

#pragma once

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
#define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)
#define new DEBUG_NEW
#endif

#include<iostream>
#include <vector>
#include <algorithm>

#include "FTIDblyConnectedEdgeList.h"

static const int ALLOWED_IMBALANCE = 1;

class FTIEdgeNode
{
public:

	FTIEdgeNode( FTIHalfEdge* i_poElement ) : m_pElement(i_poElement), m_pLeftElement(0), m_pRightElement(0), m_pHelperVertex(i_poElement->getOrigin()), m_nHeight(0){}

	FTIEdgeNode( FTIHalfEdge* i_poElement, FTIEdgeNode *i_poLeft, FTIEdgeNode *i_poRight, int i_nHeight = 0)
	{
		//FTIHalfEdge *m_pElement = new FTIHalfEdge;
		m_pElement = i_poElement;
		m_pLeftElement = i_poLeft;
		m_pRightElement = i_poRight;
		m_pHelperVertex = i_poElement->getOrigin();
		m_nHeight = i_nHeight;
	}

	~FTIEdgeNode()
	{
		//std::cout << "Edgenode delete \n" << std::endl;
	}

	FTIEdgeNode(const FTIEdgeNode &i_oRHSFTIEdgeNode)
	{
		m_pElement = i_oRHSFTIEdgeNode.m_pElement;
		m_pLeftElement = i_oRHSFTIEdgeNode.m_pLeftElement;
		m_pRightElement = i_oRHSFTIEdgeNode.m_pRightElement;
		m_pHelperVertex = i_oRHSFTIEdgeNode.m_pHelperVertex;
	}

	FTIEdgeNode &operator=(const FTIEdgeNode &i_oRHSFTIEdgeNode)
	{
		if(this != &i_oRHSFTIEdgeNode)
		{
			m_pElement = i_oRHSFTIEdgeNode.m_pElement;
			m_pLeftElement = i_oRHSFTIEdgeNode.m_pLeftElement;
			m_pRightElement = i_oRHSFTIEdgeNode.m_pRightElement;
			m_pHelperVertex = i_oRHSFTIEdgeNode.m_pHelperVertex;
		};
		return *this;
	}

	bool operator==(const FTIEdgeNode& i_oOtherFTIEdgeNode)
	{
		return (*m_pElement == *(i_oOtherFTIEdgeNode.m_pElement));
	}

	void setHelper(FTIPolyVertex* i_oHelper){ m_pHelperVertex = i_oHelper; }

	FTIPolyVertex* getHelper() { return m_pHelperVertex; }

	FTIHalfEdge *m_pElement;
	FTIEdgeNode *m_pLeftElement;
	FTIEdgeNode *m_pRightElement;
	FTIPolyVertex *m_pHelperVertex;
	int m_nHeight;
};

int Height(FTIEdgeNode *i_poEdgeNode); 


class FTIEdgeSearchTree
{
public:
	FTIEdgeSearchTree(): m_pEdgeTreeRoot(0) {};

	~FTIEdgeSearchTree()
	{
		//makeEmpty();
		//if(m_pEdgeTreeRoot != nullptr)
			//std::cout << "Search Tree delete \n" << std::endl;
	};

//////////////////////////////////////////////////////////////////////
//
// Public call to find most left edge
//
//////////////////////////////////////////////////////////////////////
	FTIHalfEdge* FindMostLeft();

//////////////////////////////////////////////////////////////////////
//
// Public call to find node which is closest to the left of a vertex
//
//////////////////////////////////////////////////////////////////////
	FTIEdgeNode* FindClosestLeft(FTIPolyVertex *i_oFTIPolyVertex);

//////////////////////////////////////////////////////////////////////
//
// Public call to insert a half edge
//
//////////////////////////////////////////////////////////////////////
	void InsertHalfEdge(FTIHalfEdge* i_poHalfEdge);

//////////////////////////////////////////////////////////////////////
//
// Public call to remove a half edge
//
//////////////////////////////////////////////////////////////////////
	void RemoveHalfEdge(FTIHalfEdge* i_poHalfEdge);

//////////////////////////////////////////////////////////////////////
//
// Public call to insert an edge node
//
//////////////////////////////////////////////////////////////////////
	void InsertEdgeNode(FTIEdgeNode* i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Public call to remove an edge node
//
//////////////////////////////////////////////////////////////////////
	void RemoveEdgeNode(FTIEdgeNode* i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Public call to find the edge node that holds a half edge
//
//////////////////////////////////////////////////////////////////////
	FTIEdgeNode* FindEdgeNode(FTIHalfEdge* i_poHalfEdge);

//////////////////////////////////////////////////////////////////////
//
// Boolean to check if empty
//
//////////////////////////////////////////////////////////////////////
	bool isEmpty() const;

//////////////////////////////////////////////////////////////////////
//
//  Public Call to empty the tree
//
//////////////////////////////////////////////////////////////////////
	void makeEmpty();

//////////////////////////////////////////////////////////////////////
//
// Rotation with left child for balancing
//
//////////////////////////////////////////////////////////////////////
	void rotateWithLeftChild(FTIEdgeNode *& i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Rotation with right child for balancing
//
//////////////////////////////////////////////////////////////////////
	void rotateWithRightChild(FTIEdgeNode *& i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Double Rotation with left child for balancing
//
//////////////////////////////////////////////////////////////////////
	void doubleWithLeftChild(FTIEdgeNode *& i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Double Rotation with left child for balancing
//
//////////////////////////////////////////////////////////////////////
	void doubleWithRightChild(FTIEdgeNode *& i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Balance tree at given node
//
//////////////////////////////////////////////////////////////////////
	void BalanceTree(FTIEdgeNode *& i_poEdgeNode);

private:

//////////////////////////////////////////////////////////////////////
//
// Private call to recursively insert a half edge
//
//////////////////////////////////////////////////////////////////////
	void InsertHalfEdge(FTIHalfEdge* i_poHalfEdge, FTIEdgeNode *&i_oEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to recursively remove a half edge
//
//////////////////////////////////////////////////////////////////////
	void RemoveHalfEdge(FTIHalfEdge* i_poHalfEdge, FTIEdgeNode *&i_oEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to recursively insert an edge node
//
//////////////////////////////////////////////////////////////////////
	void InsertEdgeNode(FTIEdgeNode* i_poNewEdgeNode, FTIEdgeNode *&i_oEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to recursively remove an edge node
//
//////////////////////////////////////////////////////////////////////
	void RemoveEdgeNode(FTIEdgeNode* i_poNewEdgeNode, FTIEdgeNode *&i_oEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to empty the tree recurrsively
//
//////////////////////////////////////////////////////////////////////
	void makeEmpty( FTIEdgeNode* &i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private Recursive Function to return the edge node that holds a half edge
//
//////////////////////////////////////////////////////////////////////
	FTIEdgeNode*FindEdgeNode(FTIHalfEdge* i_poHalfEdge, FTIEdgeNode* i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to find most left edge
//
//////////////////////////////////////////////////////////////////////
	FTIEdgeNode* FindMostLeft(FTIEdgeNode *i_oEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to closest edge to the left of a vertex
//
//////////////////////////////////////////////////////////////////////
	FTIEdgeNode* FindClosestLeft(FTIPolyVertex *i_oFTIPolyVertex, FTIEdgeNode *i_oEdgeNode);
	
//////////////////////////////////////////////////////////////////////
//
// Members of the search tree
//
//////////////////////////////////////////////////////////////////////
	FTIEdgeNode *m_pEdgeTreeRoot; //root of tree
};